{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nconst _excluded = [\"uri\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { DeviceEventEmitter, PermissionStatus } from 'expo-modules-core';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\nasync function getPermissionWithQueryAsync(name) {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n  try {\n    const {\n      state\n    } = await navigator.permissions.query({\n      name\n    });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    return PermissionStatus.UNDETERMINED;\n  }\n}\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    const error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n  const isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  const status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\nasync function setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play();\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.shouldCorrectPitch !== undefined) {\n    media.preservesPitch = status.shouldCorrectPitch;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n  return getStatusFromMedia(media);\n}\nlet mediaRecorder = null;\nlet mediaRecorderUptimeOfLastStartResume = 0;\nlet mediaRecorderDurationAlreadyRecorded = 0;\nlet mediaRecorderIsRecording = false;\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\nexport default {\n  async getStatusForVideo(element) {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(element, nativeSource, fullInitialStatus) {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element) {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(element, status) {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(element, status) {\n    return setStatusForMedia(element, status);\n  },\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(nativeSource, fullInitialStatus) {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n    media.ontimeupdate = () => {\n      DeviceEventEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media)\n      });\n    };\n    media.onerror = () => {\n      DeviceEventEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error.message\n      });\n    };\n    const status = await setStatusForMedia(media, fullInitialStatus);\n    return [media, status];\n  },\n  async unloadForSound(element) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(element, status) {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(element, status) {\n    return setStatusForMedia(element, status);\n  },\n  async getAudioRecordingStatus() {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null\n    };\n  },\n  async prepareAudioRecorder(options) {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n    const stream = await getUserMedia({\n      audio: true\n    });\n    mediaRecorder = new window.MediaRecorder(stream, options?.web || RecordingOptionsPresets.HIGH_QUALITY.web);\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n      stream.getTracks().forEach(track => track.stop());\n    });\n    const _await$this$getAudioR = await this.getAudioRecordingStatus(),\n      {\n        uri\n      } = _await$this$getAudioR,\n      status = _objectWithoutProperties(_await$this$getAudioR, _excluded);\n    return {\n      uri: null,\n      status\n    };\n  },\n  async startAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n    }\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n    }\n    mediaRecorder.pause();\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n    }\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n    const dataPromise = new Promise(resolve => mediaRecorder.addEventListener('dataavailable', e => resolve(e.data)));\n    mediaRecorder.stop();\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n    return _objectSpread(_objectSpread({}, await this.getAudioRecordingStatus()), {}, {\n      uri: url\n    });\n  },\n  async unloadAudioRecorder() {\n    mediaRecorder = null;\n  },\n  async getPermissionsAsync() {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync() {\n    try {\n      const stream = await getUserMedia({\n        audio: true\n      });\n      stream.getTracks().forEach(track => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false\n      };\n    }\n  }\n};","map":{"version":3,"names":["DeviceEventEmitter","PermissionStatus","RecordingOptionsPresets","getPermissionWithQueryAsync","name","navigator","permissions","query","state","GRANTED","DENIED","UNDETERMINED","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","audioPan","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","play","pause","preservesPitch","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","element","loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","setStatusForVideo","replayVideo","setAudioMode","setAudioIsEnabled","getStatusForSound","loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","removeAttribute","load","setStatusForSound","replaySound","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","options","stream","audio","window","MediaRecorder","web","HIGH_QUALITY","addEventListener","getTracks","forEach","track","stop","_await$this$getAudioR","_objectWithoutProperties","_excluded","startAudioRecording","resume","start","pauseAudioRecording","stopAudioRecording","dataPromise","e","data","url","URL","createObjectURL","_objectSpread","unloadAudioRecorder","getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\expo-av\\src\\ExponentAV.web.ts"],"sourcesContent":["import { DeviceEventEmitter, PermissionResponse, PermissionStatus } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nasync function setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): Promise<AVPlaybackStatus> {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play();\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.shouldCorrectPitch !== undefined) {\n    media.preservesPitch = status.shouldCorrectPitch;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      DeviceEventEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      DeviceEventEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = await setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}