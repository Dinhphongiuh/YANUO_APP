{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { PointerType } from '../../PointerType';\nimport { State } from '../../State';\nimport PointerTracker from './PointerTracker';\nexport default class GestureHandlerOrchestrator {\n  constructor() {\n    _defineProperty(this, \"gestureHandlers\", []);\n    _defineProperty(this, \"awaitingHandlers\", []);\n    _defineProperty(this, \"awaitingHandlersTags\", new Set());\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n  scheduleFinishedHandlersCleanup() {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n  cleanHandler(handler) {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n  removeHandlerFromOrchestrator(handler) {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.getTag());\n    }\n  }\n  cleanupFinishedHandlers() {\n    const handlersToRemove = new Set();\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n    this.gestureHandlers = this.gestureHandlers.filter(handler => !handlersToRemove.has(handler));\n  }\n  hasOtherHandlerToWaitFor(handler) {\n    const hasToWaitFor = otherHandler => {\n      return !this.isFinished(otherHandler.getState()) && this.shouldHandlerWaitForOther(handler, otherHandler);\n    };\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n  shouldBeCancelledByFinishedHandler(handler) {\n    const shouldBeCancelled = otherHandler => {\n      return this.shouldHandlerWaitForOther(handler, otherHandler) && otherHandler.getState() === State.END;\n    };\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n  tryActivate(handler) {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n    const handlerState = handler.getState();\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n  shouldActivate(handler) {\n    const shouldBeCancelledBy = otherHandler => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n  cleanupAwaitingHandlers(handler) {\n    const shouldWait = otherHandler => {\n      return !otherHandler.isAwaiting() && this.shouldHandlerWaitForOther(otherHandler, handler);\n    };\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.getTag());\n      }\n    }\n    this.awaitingHandlers = this.awaitingHandlers.filter(otherHandler => this.awaitingHandlersTags.has(otherHandler.getTag()));\n  }\n  onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n    this.handlingChangeSemaphore += 1;\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (!this.shouldHandlerWaitForOther(otherHandler, handler) || !this.awaitingHandlersTags.has(otherHandler.getTag())) {\n          continue;\n        }\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n        otherHandler.cancel();\n        if (otherHandler.getState() === State.END) {\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n        otherHandler.setAwaiting(false);\n      }\n    }\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n      handler.sendEvent(newState, oldState);\n    }\n    this.handlingChangeSemaphore -= 1;\n    this.scheduleFinishedHandlersCleanup();\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n  makeActive(handler) {\n    const currentState = handler.getState();\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.setAwaiting(false);\n      }\n    }\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n    if (!handler.isAwaiting()) {\n      return;\n    }\n    handler.setAwaiting(false);\n    this.awaitingHandlers = this.awaitingHandlers.filter(otherHandler => otherHandler !== handler);\n  }\n  addAwaitingHandler(handler) {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.getTag());\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n  recordHandlerIfNotPresent(handler) {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n    this.gestureHandlers.push(handler);\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n  shouldHandlerWaitForOther(handler, otherHandler) {\n    return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n  }\n  canRunSimultaneously(gh1, gh2) {\n    return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n  }\n  shouldHandlerBeCancelledBy(handler, otherHandler) {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n    if (handler.isAwaiting() || handler.getState() === State.ACTIVE) {\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n    const handlerPointers = handler.getTrackedPointersID();\n    const otherPointers = otherHandler.getTrackedPointersID();\n    if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getDelegate().getView() !== otherHandler.getDelegate().getView()) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n    return true;\n  }\n  checkOverlap(handler, otherHandler) {\n    const isPointerWithinBothBounds = pointer => {\n      const handlerX = handler.getTracker().getLastX(pointer);\n      const handlerY = handler.getTracker().getLastY(pointer);\n      const point = {\n        x: handlerX,\n        y: handlerY\n      };\n      return handler.getDelegate().isPointerInBounds(point) && otherHandler.getDelegate().isPointerInBounds(point);\n    };\n    const handlerPointers = handler.getTrackedPointersID();\n    const otherPointers = otherHandler.getTrackedPointersID();\n    return handlerPointers.some(isPointerWithinBothBounds) || otherPointers.some(isPointerWithinBothBounds);\n  }\n  isFinished(state) {\n    return state === State.END || state === State.FAILED || state === State.CANCELLED;\n  }\n  cancelMouseAndPenGestures(currentHandler) {\n    this.gestureHandlers.forEach(handler => {\n      if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.STYLUS) {\n        return;\n      }\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n  static getInstance() {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"names":["PointerType","State","PointerTracker","GestureHandlerOrchestrator","constructor","_defineProperty","Set","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","indexInGestureHandlers","gestureHandlers","indexOf","indexInAwaitingHandlers","awaitingHandlers","splice","awaitingHandlersTags","delete","getTag","handlersToRemove","i","length","isFinished","getState","isAwaiting","add","filter","has","hasOtherHandlerToWaitFor","hasToWaitFor","otherHandler","shouldHandlerWaitForOther","some","shouldBeCancelledByFinishedHandler","shouldBeCancelled","END","tryActivate","cancel","addAwaitingHandler","handlerState","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","shouldBeCancelledBy","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","shouldWait","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","sendEvent","isActive","UNDETERMINED","includes","currentState","setShouldResetProgress","activationIndex","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getDelegate","getView","checkOverlap","isPointerWithinBothBounds","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","point","x","y","isPointerInBounds","state","cancelMouseAndPenGestures","currentHandler","forEach","getPointerType","MOUSE","STYLUS","resetTracker","getInstance","instance"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\GestureHandlerOrchestrator.ts"],"sourcesContent":["import { PointerType } from '../../PointerType';\nimport { State } from '../../State';\n\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: IGestureHandler[] = [];\n  private awaitingHandlers: IGestureHandler[] = [];\n  private awaitingHandlersTags: Set<number> = new Set();\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: IGestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: IGestureHandler): void {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.getTag());\n    }\n  }\n\n  private cleanupFinishedHandlers(): void {\n    const handlersToRemove = new Set<IGestureHandler>();\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n\n    this.gestureHandlers = this.gestureHandlers.filter(\n      (handler) => !handlersToRemove.has(handler)\n    );\n  }\n\n  private hasOtherHandlerToWaitFor(handler: IGestureHandler): boolean {\n    const hasToWaitFor = (otherHandler: IGestureHandler) => {\n      return (\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      );\n    };\n\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n\n  private shouldBeCancelledByFinishedHandler(\n    handler: IGestureHandler\n  ): boolean {\n    const shouldBeCancelled = (otherHandler: IGestureHandler) => {\n      return (\n        this.shouldHandlerWaitForOther(handler, otherHandler) &&\n        otherHandler.getState() === State.END\n      );\n    };\n\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n\n  private tryActivate(handler: IGestureHandler): void {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n\n    const handlerState = handler.getState();\n\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n\n  private shouldActivate(handler: IGestureHandler): boolean {\n    const shouldBeCancelledBy = (otherHandler: IGestureHandler) => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n\n  private cleanupAwaitingHandlers(handler: IGestureHandler): void {\n    const shouldWait = (otherHandler: IGestureHandler) => {\n      return (\n        !otherHandler.isAwaiting() &&\n        this.shouldHandlerWaitForOther(otherHandler, handler)\n      );\n    };\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.getTag());\n      }\n    }\n\n    this.awaitingHandlers = this.awaitingHandlers.filter((otherHandler) =>\n      this.awaitingHandlersTags.has(otherHandler.getTag())\n    );\n  }\n\n  public onHandlerStateChange(\n    handler: IGestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (\n          !this.shouldHandlerWaitForOther(otherHandler, handler) ||\n          !this.awaitingHandlersTags.has(otherHandler.getTag())\n        ) {\n          continue;\n        }\n\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n\n        otherHandler.cancel();\n\n        if (otherHandler.getState() === State.END) {\n          // Handle edge case, where discrete gestures end immediately after activation thus\n          // their state is set to END and when the gesture they are waiting for activates they\n          // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n          // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n\n        otherHandler.setAwaiting(false);\n      }\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: IGestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.setAwaiting(false);\n      }\n    }\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (!handler.isAwaiting()) {\n      return;\n    }\n\n    handler.setAwaiting(false);\n\n    this.awaitingHandlers = this.awaitingHandlers.filter(\n      (otherHandler) => otherHandler !== handler\n    );\n  }\n\n  private addAwaitingHandler(handler: IGestureHandler): void {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.getTag());\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: IGestureHandler): void {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: IGestureHandler,\n    gh2: IGestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (handler.isAwaiting() || handler.getState() === State.ACTIVE) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getDelegate().getView() !== otherHandler.getDelegate().getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const isPointerWithinBothBounds = (pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      const point = {\n        x: handlerX,\n        y: handlerY,\n      };\n\n      return (\n        handler.getDelegate().isPointerInBounds(point) &&\n        otherHandler.getDelegate().isPointerInBounds(point)\n      );\n    };\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    return (\n      handlerPointers.some(isPointerWithinBothBounds) ||\n      otherPointers.some(isPointerWithinBothBounds)\n    );\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: IGestureHandler): void {\n    this.gestureHandlers.forEach((handler: IGestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.STYLUS\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}