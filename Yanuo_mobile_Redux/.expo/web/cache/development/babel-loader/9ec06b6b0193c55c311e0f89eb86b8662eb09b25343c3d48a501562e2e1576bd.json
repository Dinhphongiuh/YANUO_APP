{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nconst _excluded = [\"minPointers\", \"maxPointers\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport GestureHandler from './GestureHandler';\nclass IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n  updateGestureConfig(_ref) {\n    let {\n        minPointers = 2,\n        maxPointers = 2\n      } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n    return super.updateGestureConfig(_objectSpread({\n      minPointers,\n      maxPointers\n    }, props));\n  }\n  isGestureEnabledForEvent({\n    minPointers,\n    maxPointers\n  }, _recognizer, {\n    maxPointers: pointerLength\n  }) {\n    if (pointerLength > maxPointers) {\n      return {\n        failed: true\n      };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount\n    };\n  }\n}\nexport default IndiscreteGestureHandler;","map":{"version":3,"names":["GestureHandler","IndiscreteGestureHandler","shouldEnableGestureOnSetup","updateGestureConfig","_ref","minPointers","maxPointers","props","_objectWithoutProperties","_excluded","_objectSpread","isGestureEnabledForEvent","_recognizer","pointerLength","failed","validPointerCount","success"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-gesture-handler\\lib\\module\\web_hammer\\IndiscreteGestureHandler.ts"],"sourcesContent":["import GestureHandler from './GestureHandler';\n\n/**\n * The base class for **Rotation** and **Pinch** gesture handlers.\n */\nabstract class IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\n    return super.updateGestureConfig({\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    if (pointerLength > maxPointers) {\n      return { failed: true };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount,\n    };\n  }\n}\nexport default IndiscreteGestureHandler;\n"],"mappings":";;;;;AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AAKA,MAAeC,wBAAf,SAAgDD,cAAhD,CAA+D;EAC/B,IAA1BE,0BAA0BA,CAAA,EAAG;IAC/B,OAAO,KAAP;EACD;EAEDC,mBAAmBA,CAAAC,IAAA,EAAiD;IAAA,IAAhD;QAAEC,WAAW,GAAG,CAAhB;QAAmBC,WAAW,GAAG;MAAjC,CAAD,GAAAF,IAAA;MAAwCG,KAAA,GAAAC,wBAAA,CAAAJ,IAAA,EAAAK,SAAA;IACzD,OAAO,MAAMN,mBAAN,CAAAO,aAAA;MACLL,WAD+B;MAE/BC;IAF+B,GAG5BC,KAAA,CAHE,CAAP;EAKD;EAEDI,wBAAwBA,CACtB;IAAEN,WAAF;IAAeC;EAAf,CADsB,EAEtBM,WAFsB,EAGtB;IAAEN,WAAW,EAAEO;EAAf,CAHsB,EAItB;IACA,IAAIA,aAAa,GAAGP,WAApB,EAAiC;MAC/B,OAAO;QAAEQ,MAAM,EAAE;MAAV,CAAP;IACD;IACD,MAAMC,iBAAiB,GAAGF,aAAa,IAAIR,WAA3C;IACA,OAAO;MACLW,OAAO,EAAED;IADJ,CAAP;EAGD;AAzB4D;AA2B/D,eAAed,wBAAf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}