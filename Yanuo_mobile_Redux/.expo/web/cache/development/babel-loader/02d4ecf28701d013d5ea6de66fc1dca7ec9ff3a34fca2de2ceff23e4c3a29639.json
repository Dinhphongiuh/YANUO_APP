{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { State } from '../../State';\nexport default class InteractionManager {\n  constructor() {\n    _defineProperty(this, \"waitForRelations\", new Map());\n    _defineProperty(this, \"simultaneousRelations\", new Map());\n    _defineProperty(this, \"blocksHandlersRelations\", new Map());\n  }\n  configureInteractions(handler, config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n    if (config.waitFor) {\n      const waitFor = [];\n      config.waitFor.forEach(otherHandler => {\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers = [];\n      config.simultaneousHandlers.forEach(otherHandler => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n    if (config.blocksHandlers) {\n      const blocksHandlers = [];\n      config.blocksHandlers.forEach(otherHandler => {\n        if (typeof otherHandler === 'number') {\n          blocksHandlers.push(otherHandler);\n        } else {\n          blocksHandlers.push(otherHandler.handlerTag);\n        }\n      });\n      this.blocksHandlersRelations.set(handler.getTag(), blocksHandlers);\n    }\n  }\n  shouldWaitForHandlerFailure(handler, otherHandler) {\n    const waitFor = this.waitForRelations.get(handler.getTag());\n    return (waitFor === null || waitFor === void 0 ? void 0 : waitFor.find(tag => {\n      return tag === otherHandler.getTag();\n    })) !== undefined;\n  }\n  shouldRecognizeSimultaneously(handler, otherHandler) {\n    const simultaneousHandlers = this.simultaneousRelations.get(handler.getTag());\n    return (simultaneousHandlers === null || simultaneousHandlers === void 0 ? void 0 : simultaneousHandlers.find(tag => {\n      return tag === otherHandler.getTag();\n    })) !== undefined;\n  }\n  shouldRequireHandlerToWaitForFailure(handler, otherHandler) {\n    const waitFor = this.blocksHandlersRelations.get(handler.getTag());\n    return (waitFor === null || waitFor === void 0 ? void 0 : waitFor.find(tag => {\n      return tag === otherHandler.getTag();\n    })) !== undefined;\n  }\n  shouldHandlerBeCancelledBy(_handler, otherHandler) {\n    var _otherHandler$isButto;\n    const isNativeHandler = otherHandler.constructor.name === 'NativeViewGestureHandler';\n    const isActive = otherHandler.getState() === State.ACTIVE;\n    const isButton = ((_otherHandler$isButto = otherHandler.isButton) === null || _otherHandler$isButto === void 0 ? void 0 : _otherHandler$isButto.call(otherHandler)) === true;\n    return isNativeHandler && isActive && !isButton;\n  }\n  dropRelationsForHandlerWithTag(handlerTag) {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n    this.blocksHandlersRelations.delete(handlerTag);\n  }\n  reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n    this.blocksHandlersRelations.clear();\n  }\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n    return this.instance;\n  }\n}\n_defineProperty(InteractionManager, \"instance\", void 0);","map":{"version":3,"names":["State","InteractionManager","constructor","_defineProperty","Map","configureInteractions","handler","config","dropRelationsForHandlerWithTag","getTag","waitFor","forEach","otherHandler","push","handlerTag","waitForRelations","set","simultaneousHandlers","simultaneousRelations","blocksHandlers","blocksHandlersRelations","shouldWaitForHandlerFailure","get","find","tag","undefined","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","shouldHandlerBeCancelledBy","_handler","_otherHandler$isButto","isNativeHandler","name","isActive","getState","ACTIVE","isButton","call","delete","reset","clear","getInstance","instance"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\InteractionManager.ts"],"sourcesContent":["import type IGestureHandler from '../handlers/IGestureHandler';\nimport { State } from '../../State';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private static instance: InteractionManager;\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n  private readonly blocksHandlersRelations: Map<number, number[]> = new Map();\n\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  public configureInteractions(handler: IGestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((otherHandler: Handler): void => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n\n    if (config.blocksHandlers) {\n      const blocksHandlers: number[] = [];\n      config.blocksHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          blocksHandlers.push(otherHandler);\n        } else {\n          blocksHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.blocksHandlersRelations.set(handler.getTag(), blocksHandlers);\n    }\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n\n    return (\n      waitFor?.find((tag: number) => {\n        return tag === otherHandler.getTag();\n      }) !== undefined\n    );\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    const simultaneousHandlers: number[] | undefined =\n      this.simultaneousRelations.get(handler.getTag());\n\n    return (\n      simultaneousHandlers?.find((tag: number) => {\n        return tag === otherHandler.getTag();\n      }) !== undefined\n    );\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.blocksHandlersRelations.get(\n      handler.getTag()\n    );\n\n    return (\n      waitFor?.find((tag: number) => {\n        return tag === otherHandler.getTag();\n      }) !== undefined\n    );\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // We check constructor name instead of using `instanceof` in order do avoid circular dependencies\n    const isNativeHandler =\n      otherHandler.constructor.name === 'NativeViewGestureHandler';\n    const isActive = otherHandler.getState() === State.ACTIVE;\n    const isButton = otherHandler.isButton?.() === true;\n\n    return isNativeHandler && isActive && !isButton;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n    this.blocksHandlersRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n    this.blocksHandlersRelations.clear();\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n\n    return this.instance;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AACA,SAASA,KAAT,QAAsB,aAAtB;AAGA,eAAe,MAAMC,kBAAN,CAAyB;EAQ9BC,WAAWA,CAAA,EAAG;IAAAC,eAAA,2BANqC,IAAIC,GAAJ,EAMrC;IAAAD,eAAA,gCAL0C,IAAIC,GAAJ,EAK1C;IAAAD,eAAA,kCAJ4C,IAAIC,GAAJ,EAI5C;EAAE;EAEjBC,qBAAqBA,CAACC,OAAD,EAA2BC,MAA3B,EAA2C;IACrE,KAAKC,8BAAL,CAAoCF,OAAO,CAACG,MAAR,EAApC;IAEA,IAAIF,MAAM,CAACG,OAAX,EAAoB;MAClB,MAAMA,OAAiB,GAAG,EAA1B;MACAH,MAAM,CAACG,OAAP,CAAeC,OAAf,CAAwBC,YAAD,IAAiC;QAEtD,IAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;UACpCF,OAAO,CAACG,IAAR,CAAaD,YAAb;QACD,CAFD,MAEO;UAELF,OAAO,CAACG,IAAR,CAAaD,YAAY,CAACE,UAA1B;QACD;MACF,CARD;MAUA,KAAKC,gBAAL,CAAsBC,GAAtB,CAA0BV,OAAO,CAACG,MAAR,EAA1B,EAA4CC,OAA5C;IACD;IAED,IAAIH,MAAM,CAACU,oBAAX,EAAiC;MAC/B,MAAMA,oBAA8B,GAAG,EAAvC;MACAV,MAAM,CAACU,oBAAP,CAA4BN,OAA5B,CAAqCC,YAAD,IAAiC;QACnE,IAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;UACpCK,oBAAoB,CAACJ,IAArB,CAA0BD,YAA1B;QACD,CAFD,MAEO;UACLK,oBAAoB,CAACJ,IAArB,CAA0BD,YAAY,CAACE,UAAvC;QACD;MACF,CAND;MAQA,KAAKI,qBAAL,CAA2BF,GAA3B,CAA+BV,OAAO,CAACG,MAAR,EAA/B,EAAiDQ,oBAAjD;IACD;IAED,IAAIV,MAAM,CAACY,cAAX,EAA2B;MACzB,MAAMA,cAAwB,GAAG,EAAjC;MACAZ,MAAM,CAACY,cAAP,CAAsBR,OAAtB,CAA+BC,YAAD,IAAiC;QAC7D,IAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;UACpCO,cAAc,CAACN,IAAf,CAAoBD,YAApB;QACD,CAFD,MAEO;UACLO,cAAc,CAACN,IAAf,CAAoBD,YAAY,CAACE,UAAjC;QACD;MACF,CAND;MAQA,KAAKM,uBAAL,CAA6BJ,GAA7B,CAAiCV,OAAO,CAACG,MAAR,EAAjC,EAAmDU,cAAnD;IACD;EACF;EAEME,2BAA2BA,CAChCf,OADgC,EAEhCM,YAFgC,EAGvB;IACT,MAAMF,OAA6B,GAAG,KAAKK,gBAAL,CAAsBO,GAAtB,CACpChB,OAAO,CAACG,MAAR,EADoC,CAAtC;IAIA,OACE,CAAAC,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEa,IAAT,CAAeC,GAAD,IAAiB;MAC7B,OAAOA,GAAG,KAAKZ,YAAY,CAACH,MAAb,EAAf;IACD,CAFD,OAEOgB,SAHT;EAKD;EAEMC,6BAA6BA,CAClCpB,OADkC,EAElCM,YAFkC,EAGzB;IACT,MAAMK,oBAA0C,GAC9C,KAAKC,qBAAL,CAA2BI,GAA3B,CAA+BhB,OAAO,CAACG,MAAR,EAA/B,CADF;IAGA,OACE,CAAAQ,oBAAoB,SAApB,IAAAA,oBAAoB,WAApB,YAAAA,oBAAoB,CAAEM,IAAtB,CAA4BC,GAAD,IAAiB;MAC1C,OAAOA,GAAG,KAAKZ,YAAY,CAACH,MAAb,EAAf;IACD,CAFD,OAEOgB,SAHT;EAKD;EAEME,oCAAoCA,CACzCrB,OADyC,EAEzCM,YAFyC,EAGhC;IACT,MAAMF,OAA6B,GAAG,KAAKU,uBAAL,CAA6BE,GAA7B,CACpChB,OAAO,CAACG,MAAR,EADoC,CAAtC;IAIA,OACE,CAAAC,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEa,IAAT,CAAeC,GAAD,IAAiB;MAC7B,OAAOA,GAAG,KAAKZ,YAAY,CAACH,MAAb,EAAf;IACD,CAFD,OAEOgB,SAHT;EAKD;EAEMG,0BAA0BA,CAC/BC,QAD+B,EAE/BjB,YAF+B,EAGtB;IAAA,IAAAkB,qBAAA;IAET,MAAMC,eAAe,GACnBnB,YAAY,CAACV,WAAb,CAAyB8B,IAAzB,KAAkC,0BADpC;IAEA,MAAMC,QAAQ,GAAGrB,YAAY,CAACsB,QAAb,OAA4BlC,KAAK,CAACmC,MAAnD;IACA,MAAMC,QAAQ,GAAG,EAAAN,qBAAA,GAAAlB,YAAY,CAACwB,QAAb,cAAAN,qBAAA,uBAAAA,qBAAA,CAAAO,IAAA,CAAAzB,YAAY,OAAkB,IAA/C;IAEA,OAAOmB,eAAe,IAAIE,QAAnB,IAA+B,CAACG,QAAvC;EACD;EAEM5B,8BAA8BA,CAACM,UAAD,EAA2B;IAC9D,KAAKC,gBAAL,CAAsBuB,MAAtB,CAA6BxB,UAA7B;IACA,KAAKI,qBAAL,CAA2BoB,MAA3B,CAAkCxB,UAAlC;IACA,KAAKM,uBAAL,CAA6BkB,MAA7B,CAAoCxB,UAApC;EACD;EAEMyB,KAAKA,CAAA,EAAG;IACb,KAAKxB,gBAAL,CAAsByB,KAAtB;IACA,KAAKtB,qBAAL,CAA2BsB,KAA3B;IACA,KAAKpB,uBAAL,CAA6BoB,KAA7B;EACD;EAEwB,OAAXC,WAAWA,CAAA,EAAuB;IAC9C,IAAI,CAAC,KAAKC,QAAV,EAAoB;MAClB,KAAKA,QAAL,GAAgB,IAAIzC,kBAAJ,EAAhB;IACD;IAED,OAAO,KAAKyC,QAAZ;EACD;AAlIqC;gBAAnBzC,kB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}