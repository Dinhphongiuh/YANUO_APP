{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport useLatestCallback from 'use-latest-callback';\nimport { TabBarIndicator } from './TabBarIndicator';\nimport { TabBarItem } from './TabBarItem';\nimport { useAnimatedValue } from './useAnimatedValue';\nconst Separator = _ref => {\n  let {\n    width\n  } = _ref;\n  return React.createElement(View, {\n    style: {\n      width\n    }\n  });\n};\nconst getFlattenedTabWidth = style => {\n  const tabStyle = StyleSheet.flatten(style);\n  return tabStyle === null || tabStyle === void 0 ? void 0 : tabStyle.width;\n};\nconst getComputedTabWidth = (index, layout, routes, scrollEnabled, tabWidths, flattenedWidth) => {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        const width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n  if (scrollEnabled) {\n    return layout.width / 5 * 2;\n  }\n  return layout.width / routes.length;\n};\nconst getMaxScrollDistance = (tabBarWidth, layoutWidth) => tabBarWidth - layoutWidth;\nconst getTranslateX = (scrollAmount, maxScrollDistance) => Animated.multiply(Platform.OS === 'android' && I18nManager.isRTL ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1)) : scrollAmount, I18nManager.isRTL ? 1 : -1);\nconst getTabBarWidth = _ref2 => {\n  let {\n    navigationState,\n    layout,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    tabWidths\n  } = _ref2;\n  const {\n    routes\n  } = navigationState;\n  return routes.reduce((acc, _, i) => acc + (i > 0 ? gap ?? 0 : 0) + getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth), 0);\n};\nconst normalizeScrollValue = _ref3 => {\n  let {\n    layout,\n    navigationState,\n    gap,\n    scrollEnabled,\n    tabWidths,\n    value,\n    flattenedTabWidth\n  } = _ref3;\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth\n  });\n  const maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n  if (Platform.OS === 'android' && I18nManager.isRTL) {\n    return maxDistance - scrollValue;\n  }\n  return scrollValue;\n};\nconst getScrollAmount = _ref4 => {\n  let {\n    layout,\n    navigationState,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    tabWidths\n  } = _ref4;\n  const centerDistance = Array.from({\n    length: navigationState.index + 1\n  }).reduce((total, _, i) => {\n    const tabWidth = getComputedTabWidth(i, layout, navigationState.routes, scrollEnabled, tabWidths, flattenedTabWidth);\n    return total + (navigationState.index === i ? (tabWidth + (gap ?? 0)) / 2 : tabWidth + (gap ?? 0));\n  }, 0);\n  const scrollAmount = centerDistance - layout.width / 2;\n  return normalizeScrollValue({\n    layout,\n    navigationState,\n    tabWidths,\n    value: scrollAmount,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth\n  });\n};\nconst getLabelTextDefault = _ref5 => {\n  let {\n    route\n  } = _ref5;\n  return route.title;\n};\nconst getAccessibleDefault = _ref6 => {\n  let {\n    route\n  } = _ref6;\n  return typeof route.accessible !== 'undefined' ? route.accessible : true;\n};\nconst getAccessibilityLabelDefault = _ref7 => {\n  let {\n    route\n  } = _ref7;\n  return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n};\nconst renderIndicatorDefault = props => React.createElement(TabBarIndicator, props);\nconst getTestIdDefault = _ref8 => {\n  let {\n    route\n  } = _ref8;\n  return route.testID;\n};\nconst MEASURE_PER_BATCH = 10;\nexport function TabBar(_ref9) {\n  let {\n    getLabelText = getLabelTextDefault,\n    getAccessible = getAccessibleDefault,\n    getAccessibilityLabel = getAccessibilityLabelDefault,\n    getTestID = getTestIdDefault,\n    renderIndicator = renderIndicatorDefault,\n    gap = 0,\n    scrollEnabled,\n    jumpTo,\n    navigationState,\n    position,\n    activeColor,\n    bounces,\n    contentContainerStyle,\n    inactiveColor,\n    indicatorContainerStyle,\n    indicatorStyle,\n    labelStyle,\n    onTabLongPress,\n    onTabPress,\n    pressColor,\n    pressOpacity,\n    renderBadge,\n    renderIcon,\n    renderLabel,\n    renderTabBarItem,\n    style,\n    tabStyle,\n    testID,\n    android_ripple\n  } = _ref9;\n  const [layout, setLayout] = React.useState({\n    width: 0,\n    height: 0\n  });\n  const [tabWidths, setTabWidths] = React.useState({});\n  const flatListRef = React.useRef(null);\n  const isFirst = React.useRef(true);\n  const scrollAmount = useAnimatedValue(0);\n  const measuredTabWidths = React.useRef({});\n  const {\n    routes\n  } = navigationState;\n  const flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  const isWidthDynamic = flattenedTabWidth === 'auto';\n  const scrollOffset = getScrollAmount({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth\n  });\n  const hasMeasuredTabWidths = Boolean(layout.width) && routes.slice(0, navigationState.index).every(r => typeof tabWidths[r.key] === 'number');\n  React.useEffect(() => {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      return;\n    }\n    if (scrollEnabled) {\n      var _flatListRef$current;\n      (_flatListRef$current = flatListRef.current) === null || _flatListRef$current === void 0 ? void 0 : _flatListRef$current.scrollToOffset({\n        offset: scrollOffset,\n        animated: true\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n  const handleLayout = e => {\n    const {\n      height,\n      width\n    } = e.nativeEvent.layout;\n    setLayout(layout => layout.width === width && layout.height === height ? layout : {\n      width,\n      height\n    });\n  };\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth\n  });\n  const separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  const separatorPercent = separatorsWidth / tabBarWidth * 100;\n  const tabBarWidthPercent = `${routes.length * 40}%`;\n  const translateX = React.useMemo(() => getTranslateX(scrollAmount, getMaxScrollDistance(tabBarWidth, layout.width)), [layout.width, scrollAmount, tabBarWidth]);\n  const renderItem = React.useCallback(_ref10 => {\n    let {\n      item: route,\n      index\n    } = _ref10;\n    const props = {\n      key: route.key,\n      position: position,\n      route: route,\n      navigationState: navigationState,\n      getAccessibilityLabel: getAccessibilityLabel,\n      getAccessible: getAccessible,\n      getLabelText: getLabelText,\n      getTestID: getTestID,\n      renderBadge: renderBadge,\n      renderIcon: renderIcon,\n      renderLabel: renderLabel,\n      activeColor: activeColor,\n      inactiveColor: inactiveColor,\n      pressColor: pressColor,\n      pressOpacity: pressOpacity,\n      onLayout: isWidthDynamic ? e => {\n        measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n        if (routes.length > MEASURE_PER_BATCH && index === MEASURE_PER_BATCH && routes.slice(0, MEASURE_PER_BATCH).every(r => typeof measuredTabWidths.current[r.key] === 'number')) {\n          setTabWidths(_objectSpread({}, measuredTabWidths.current));\n        } else if (routes.every(r => typeof measuredTabWidths.current[r.key] === 'number')) {\n          setTabWidths(_objectSpread({}, measuredTabWidths.current));\n        }\n      } : undefined,\n      onPress: () => {\n        const event = {\n          route,\n          defaultPrevented: false,\n          preventDefault: () => {\n            event.defaultPrevented = true;\n          }\n        };\n        onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n        if (event.defaultPrevented) {\n          return;\n        }\n        jumpTo(route.key);\n      },\n      onLongPress: () => onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({\n        route\n      }),\n      labelStyle: labelStyle,\n      style: tabStyle,\n      defaultTabWidth: !isWidthDynamic ? getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, getFlattenedTabWidth(tabStyle)) : undefined,\n      android_ripple\n    };\n    return React.createElement(React.Fragment, null, gap > 0 && index > 0 ? React.createElement(Separator, {\n      width: gap\n    }) : null, renderTabBarItem ? renderTabBarItem(props) : React.createElement(TabBarItem, props));\n  }, [activeColor, android_ripple, gap, getAccessibilityLabel, getAccessible, getLabelText, getTestID, inactiveColor, isWidthDynamic, jumpTo, labelStyle, layout, navigationState, onTabLongPress, onTabPress, position, pressColor, pressOpacity, renderBadge, renderIcon, renderLabel, renderTabBarItem, routes, scrollEnabled, tabStyle, tabWidths]);\n  const keyExtractor = React.useCallback(item => item.key, []);\n  const contentContainerStyleMemoized = React.useMemo(() => [styles.tabContent, scrollEnabled ? {\n    width: tabBarWidth > separatorsWidth ? tabBarWidth : tabBarWidthPercent\n  } : styles.container, contentContainerStyle], [contentContainerStyle, scrollEnabled, separatorsWidth, tabBarWidth, tabBarWidthPercent]);\n  const handleScroll = React.useMemo(() => Animated.event([{\n    nativeEvent: {\n      contentOffset: {\n        x: scrollAmount\n      }\n    }\n  }], {\n    useNativeDriver: true\n  }), [scrollAmount]);\n  const handleViewableItemsChanged = useLatestCallback(_ref11 => {\n    let {\n      changed\n    } = _ref11;\n    if (routes.length <= MEASURE_PER_BATCH) {\n      return;\n    }\n    const item = changed[changed.length - 1];\n    const index = (item === null || item === void 0 ? void 0 : item.index) || 0;\n    if (item.isViewable && (index % 10 === 0 || index === navigationState.index || index === routes.length - 1)) {\n      setTabWidths(_objectSpread({}, measuredTabWidths.current));\n    }\n  });\n  return React.createElement(Animated.View, {\n    onLayout: handleLayout,\n    style: [styles.tabBar, style]\n  }, React.createElement(Animated.View, {\n    pointerEvents: \"none\",\n    style: [styles.indicatorContainer, scrollEnabled ? {\n      transform: [{\n        translateX\n      }]\n    } : null, tabBarWidth > separatorsWidth ? {\n      width: tabBarWidth - separatorsWidth\n    } : scrollEnabled ? {\n      width: tabBarWidthPercent\n    } : null, indicatorContainerStyle]\n  }, renderIndicator({\n    position,\n    layout,\n    navigationState,\n    jumpTo,\n    width: isWidthDynamic ? 'auto' : `${(100 - separatorPercent) / routes.length}%`,\n    style: indicatorStyle,\n    getTabWidth: i => getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth),\n    gap\n  })), React.createElement(View, {\n    style: styles.scroll\n  }, React.createElement(Animated.FlatList, {\n    data: routes,\n    keyExtractor: keyExtractor,\n    horizontal: true,\n    accessibilityRole: \"tablist\",\n    keyboardShouldPersistTaps: \"handled\",\n    scrollEnabled: scrollEnabled,\n    bounces: bounces,\n    initialNumToRender: MEASURE_PER_BATCH,\n    onViewableItemsChanged: handleViewableItemsChanged,\n    alwaysBounceHorizontal: false,\n    scrollsToTop: false,\n    showsHorizontalScrollIndicator: false,\n    showsVerticalScrollIndicator: false,\n    automaticallyAdjustContentInsets: false,\n    overScrollMode: \"never\",\n    contentContainerStyle: contentContainerStyleMemoized,\n    scrollEventThrottle: 16,\n    renderItem: renderItem,\n    onScroll: handleScroll,\n    ref: flatListRef,\n    testID: testID\n  })));\n}\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0\n    },\n    zIndex: 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"names":["React","Animated","I18nManager","Platform","StyleSheet","View","useLatestCallback","TabBarIndicator","TabBarItem","useAnimatedValue","Separator","_ref","width","createElement","style","getFlattenedTabWidth","tabStyle","flatten","getComputedTabWidth","index","layout","routes","scrollEnabled","tabWidths","flattenedWidth","key","endsWith","parseFloat","Number","isFinite","length","getMaxScrollDistance","tabBarWidth","layoutWidth","getTranslateX","scrollAmount","maxScrollDistance","multiply","OS","isRTL","add","getTabBarWidth","_ref2","navigationState","gap","flattenedTabWidth","reduce","acc","_","i","normalizeScrollValue","_ref3","value","maxDistance","scrollValue","Math","max","min","getScrollAmount","_ref4","centerDistance","Array","from","total","tabWidth","getLabelTextDefault","_ref5","route","title","getAccessibleDefault","_ref6","accessible","getAccessibilityLabelDefault","_ref7","accessibilityLabel","undefined","renderIndicatorDefault","props","getTestIdDefault","_ref8","testID","MEASURE_PER_BATCH","TabBar","_ref9","getLabelText","getAccessible","getAccessibilityLabel","getTestID","renderIndicator","jumpTo","position","activeColor","bounces","contentContainerStyle","inactiveColor","indicatorContainerStyle","indicatorStyle","labelStyle","onTabLongPress","onTabPress","pressColor","pressOpacity","renderBadge","renderIcon","renderLabel","renderTabBarItem","android_ripple","setLayout","useState","height","setTabWidths","flatListRef","useRef","isFirst","measuredTabWidths","isWidthDynamic","scrollOffset","hasMeasuredTabWidths","Boolean","slice","every","r","useEffect","current","_flatListRef$current","scrollToOffset","offset","animated","handleLayout","e","nativeEvent","separatorsWidth","separatorPercent","tabBarWidthPercent","translateX","useMemo","renderItem","useCallback","_ref10","item","onLayout","_objectSpread","onPress","event","defaultPrevented","preventDefault","onLongPress","defaultTabWidth","Fragment","keyExtractor","contentContainerStyleMemoized","styles","tabContent","container","handleScroll","contentOffset","x","useNativeDriver","handleViewableItemsChanged","_ref11","changed","isViewable","tabBar","pointerEvents","indicatorContainer","transform","getTabWidth","scroll","FlatList","data","horizontal","accessibilityRole","keyboardShouldPersistTaps","initialNumToRender","onViewableItemsChanged","alwaysBounceHorizontal","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","automaticallyAdjustContentInsets","overScrollMode","scrollEventThrottle","onScroll","ref","create","flex","overflow","select","default","web","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","zIndex","flexDirection","flexWrap","top","left","right","bottom"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-tab-view\\src\\TabBar.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  FlatList,\n  I18nManager,\n  LayoutChangeEvent,\n  ListRenderItemInfo,\n  Platform,\n  PressableAndroidRippleConfig,\n  StyleProp,\n  StyleSheet,\n  TextStyle,\n  View,\n  ViewStyle,\n  ViewToken,\n} from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\n\nimport { Props as IndicatorProps, TabBarIndicator } from './TabBarIndicator';\nimport { Props as TabBarItemProps, TabBarItem } from './TabBarItem';\nimport type {\n  Event,\n  Layout,\n  NavigationState,\n  Route,\n  Scene,\n  SceneRendererProps,\n} from './types';\nimport { useAnimatedValue } from './useAnimatedValue';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText?: (scene: Scene<T>) => string | undefined;\n  getAccessible?: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel?: (scene: Scene<T>) => string | undefined;\n  getTestID?: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator?: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n  gap?: number;\n  testID?: string;\n  android_ripple?: PressableAndroidRippleConfig;\n};\n\ntype FlattenedTabWidth = string | number | undefined;\n\nconst Separator = ({ width }: { width: number }) => {\n  return <View style={{ width }} />;\n};\n\nconst getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n  const tabStyle = StyleSheet.flatten(style);\n\n  return tabStyle?.width;\n};\n\nconst getComputedTabWidth = (\n  index: number,\n  layout: Layout,\n  routes: Route[],\n  scrollEnabled: boolean | undefined,\n  tabWidths: { [key: string]: number },\n  flattenedWidth: FlattenedTabWidth\n) => {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        const width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n\n  if (scrollEnabled) {\n    return (layout.width / 5) * 2;\n  }\n  return layout.width / routes.length;\n};\n\nconst getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n  tabBarWidth - layoutWidth;\n\nconst getTranslateX = (\n  scrollAmount: Animated.Value,\n  maxScrollDistance: number\n) =>\n  Animated.multiply(\n    Platform.OS === 'android' && I18nManager.isRTL\n      ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n      : scrollAmount,\n    I18nManager.isRTL ? 1 : -1\n  );\n\nconst getTabBarWidth = <T extends Route>({\n  navigationState,\n  layout,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  tabWidths,\n}: Pick<Props<T>, 'navigationState' | 'gap' | 'layout' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const { routes } = navigationState;\n\n  return routes.reduce<number>(\n    (acc, _, i) =>\n      acc +\n      (i > 0 ? gap ?? 0 : 0) +\n      getComputedTabWidth(\n        i,\n        layout,\n        routes,\n        scrollEnabled,\n        tabWidths,\n        flattenedTabWidth\n      ),\n    0\n  );\n};\n\nconst normalizeScrollValue = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  tabWidths,\n  value,\n  flattenedTabWidth,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'gap' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  value: number;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n  const maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n  if (Platform.OS === 'android' && I18nManager.isRTL) {\n    // On Android, scroll value is not applied in reverse in RTL\n    // so we need to manually adjust it to apply correct value\n    return maxDistance - scrollValue;\n  }\n\n  return scrollValue;\n};\n\nconst getScrollAmount = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  tabWidths,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'scrollEnabled' | 'gap'> & {\n  tabWidths: Record<string, number>;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const centerDistance = Array.from({\n    length: navigationState.index + 1,\n  }).reduce<number>((total, _, i) => {\n    const tabWidth = getComputedTabWidth(\n      i,\n      layout,\n      navigationState.routes,\n      scrollEnabled,\n      tabWidths,\n      flattenedTabWidth\n    );\n\n    // To get the current index centered we adjust scroll amount by width of indexes\n    // 0 through (i - 1) and add half the width of current index i\n    return (\n      total +\n      (navigationState.index === i\n        ? (tabWidth + (gap ?? 0)) / 2\n        : tabWidth + (gap ?? 0))\n    );\n  }, 0);\n\n  const scrollAmount = centerDistance - layout.width / 2;\n\n  return normalizeScrollValue({\n    layout,\n    navigationState,\n    tabWidths,\n    value: scrollAmount,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n};\n\nconst getLabelTextDefault = ({ route }: Scene<Route>) => route.title;\n\nconst getAccessibleDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessible !== 'undefined' ? route.accessible : true;\n\nconst getAccessibilityLabelDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessibilityLabel === 'string'\n    ? route.accessibilityLabel\n    : typeof route.title === 'string'\n    ? route.title\n    : undefined;\n\nconst renderIndicatorDefault = (props: IndicatorProps<Route>) => (\n  <TabBarIndicator {...props} />\n);\n\nconst getTestIdDefault = ({ route }: Scene<Route>) => route.testID;\n\n// How many items measurements should we update per batch.\n// Defaults to 10, since that's whats FlatList is using in initialNumToRender.\nconst MEASURE_PER_BATCH = 10;\n\nexport function TabBar<T extends Route>({\n  getLabelText = getLabelTextDefault,\n  getAccessible = getAccessibleDefault,\n  getAccessibilityLabel = getAccessibilityLabelDefault,\n  getTestID = getTestIdDefault,\n  renderIndicator = renderIndicatorDefault,\n  gap = 0,\n  scrollEnabled,\n  jumpTo,\n  navigationState,\n  position,\n  activeColor,\n  bounces,\n  contentContainerStyle,\n  inactiveColor,\n  indicatorContainerStyle,\n  indicatorStyle,\n  labelStyle,\n  onTabLongPress,\n  onTabPress,\n  pressColor,\n  pressOpacity,\n  renderBadge,\n  renderIcon,\n  renderLabel,\n  renderTabBarItem,\n  style,\n  tabStyle,\n  testID,\n  android_ripple,\n}: Props<T>) {\n  const [layout, setLayout] = React.useState<Layout>({ width: 0, height: 0 });\n  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n  const flatListRef = React.useRef<FlatList | null>(null);\n  const isFirst = React.useRef(true);\n  const scrollAmount = useAnimatedValue(0);\n  const measuredTabWidths = React.useRef<Record<string, number>>({});\n\n  const { routes } = navigationState;\n  const flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  const isWidthDynamic = flattenedTabWidth === 'auto';\n  const scrollOffset = getScrollAmount({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n\n  const hasMeasuredTabWidths =\n    Boolean(layout.width) &&\n    routes\n      .slice(0, navigationState.index)\n      .every((r) => typeof tabWidths[r.key] === 'number');\n\n  React.useEffect(() => {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      return;\n    }\n\n    if (scrollEnabled) {\n      flatListRef.current?.scrollToOffset({\n        offset: scrollOffset,\n        animated: true,\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n\n  const handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    setLayout((layout) =>\n      layout.width === width && layout.height === height\n        ? layout\n        : { width, height }\n    );\n  };\n\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n\n  const separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  const separatorPercent = (separatorsWidth / tabBarWidth) * 100;\n  const tabBarWidthPercent = `${routes.length * 40}%`;\n\n  const translateX = React.useMemo(\n    () =>\n      getTranslateX(\n        scrollAmount,\n        getMaxScrollDistance(tabBarWidth, layout.width)\n      ),\n    [layout.width, scrollAmount, tabBarWidth]\n  );\n\n  const renderItem = React.useCallback(\n    ({ item: route, index }: ListRenderItemInfo<T>) => {\n      const props: TabBarItemProps<T> & { key: string } = {\n        key: route.key,\n        position: position,\n        route: route,\n        navigationState: navigationState,\n        getAccessibilityLabel: getAccessibilityLabel,\n        getAccessible: getAccessible,\n        getLabelText: getLabelText,\n        getTestID: getTestID,\n        renderBadge: renderBadge,\n        renderIcon: renderIcon,\n        renderLabel: renderLabel,\n        activeColor: activeColor,\n        inactiveColor: inactiveColor,\n        pressColor: pressColor,\n        pressOpacity: pressOpacity,\n        onLayout: isWidthDynamic\n          ? (e: LayoutChangeEvent) => {\n              measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n\n              // When we have measured widths for all of the tabs, we should updates the state\n              // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n              // If we have more than 10 routes divide updating tabWidths into multiple batches. Here we update only first batch of 10 items.\n              if (\n                routes.length > MEASURE_PER_BATCH &&\n                index === MEASURE_PER_BATCH &&\n                routes\n                  .slice(0, MEASURE_PER_BATCH)\n                  .every(\n                    (r) => typeof measuredTabWidths.current[r.key] === 'number'\n                  )\n              ) {\n                setTabWidths({ ...measuredTabWidths.current });\n              } else if (\n                routes.every(\n                  (r) => typeof measuredTabWidths.current[r.key] === 'number'\n                )\n              ) {\n                // When we have measured widths for all of the tabs, we should updates the state\n                // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n                setTabWidths({ ...measuredTabWidths.current });\n              }\n            }\n          : undefined,\n        onPress: () => {\n          const event: Scene<T> & Event = {\n            route,\n            defaultPrevented: false,\n            preventDefault: () => {\n              event.defaultPrevented = true;\n            },\n          };\n\n          onTabPress?.(event);\n\n          if (event.defaultPrevented) {\n            return;\n          }\n\n          jumpTo(route.key);\n        },\n        onLongPress: () => onTabLongPress?.({ route }),\n        labelStyle: labelStyle,\n        style: tabStyle,\n        // Calculate the deafult width for tab for FlatList to work\n        defaultTabWidth: !isWidthDynamic\n          ? getComputedTabWidth(\n              index,\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              getFlattenedTabWidth(tabStyle)\n            )\n          : undefined,\n        android_ripple,\n      };\n\n      return (\n        <>\n          {gap > 0 && index > 0 ? <Separator width={gap} /> : null}\n          {renderTabBarItem ? (\n            renderTabBarItem(props)\n          ) : (\n            <TabBarItem {...props} />\n          )}\n        </>\n      );\n    },\n    [\n      activeColor,\n      android_ripple,\n      gap,\n      getAccessibilityLabel,\n      getAccessible,\n      getLabelText,\n      getTestID,\n      inactiveColor,\n      isWidthDynamic,\n      jumpTo,\n      labelStyle,\n      layout,\n      navigationState,\n      onTabLongPress,\n      onTabPress,\n      position,\n      pressColor,\n      pressOpacity,\n      renderBadge,\n      renderIcon,\n      renderLabel,\n      renderTabBarItem,\n      routes,\n      scrollEnabled,\n      tabStyle,\n      tabWidths,\n    ]\n  );\n\n  const keyExtractor = React.useCallback((item: T) => item.key, []);\n\n  const contentContainerStyleMemoized = React.useMemo(\n    () => [\n      styles.tabContent,\n      scrollEnabled\n        ? {\n            width:\n              tabBarWidth > separatorsWidth ? tabBarWidth : tabBarWidthPercent,\n          }\n        : styles.container,\n      contentContainerStyle,\n    ],\n    [\n      contentContainerStyle,\n      scrollEnabled,\n      separatorsWidth,\n      tabBarWidth,\n      tabBarWidthPercent,\n    ]\n  );\n\n  const handleScroll = React.useMemo(\n    () =>\n      Animated.event(\n        [\n          {\n            nativeEvent: {\n              contentOffset: { x: scrollAmount },\n            },\n          },\n        ],\n        { useNativeDriver: true }\n      ),\n    [scrollAmount]\n  );\n\n  const handleViewableItemsChanged = useLatestCallback(\n    ({ changed }: { changed: ViewToken[] }) => {\n      if (routes.length <= MEASURE_PER_BATCH) {\n        return;\n      }\n      // Get next vievable item\n      const item = changed[changed.length - 1];\n      const index = item?.index || 0;\n      if (\n        item.isViewable &&\n        (index % 10 === 0 ||\n          index === navigationState.index ||\n          index === routes.length - 1)\n      ) {\n        setTabWidths({ ...measuredTabWidths.current });\n      }\n    }\n  );\n\n  return (\n    <Animated.View onLayout={handleLayout} style={[styles.tabBar, style]}>\n      <Animated.View\n        pointerEvents=\"none\"\n        style={[\n          styles.indicatorContainer,\n          scrollEnabled ? { transform: [{ translateX }] as any } : null,\n          tabBarWidth > separatorsWidth\n            ? { width: tabBarWidth - separatorsWidth }\n            : scrollEnabled\n            ? { width: tabBarWidthPercent }\n            : null,\n          indicatorContainerStyle,\n        ]}\n      >\n        {renderIndicator({\n          position,\n          layout,\n          navigationState,\n          jumpTo,\n          width: isWidthDynamic\n            ? 'auto'\n            : `${(100 - separatorPercent) / routes.length}%`,\n          style: indicatorStyle,\n          getTabWidth: (i: number) =>\n            getComputedTabWidth(\n              i,\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              flattenedTabWidth\n            ),\n          gap,\n        })}\n      </Animated.View>\n      <View style={styles.scroll}>\n        <Animated.FlatList\n          data={routes as Animated.WithAnimatedValue<T>[]}\n          keyExtractor={keyExtractor}\n          horizontal\n          accessibilityRole=\"tablist\"\n          keyboardShouldPersistTaps=\"handled\"\n          scrollEnabled={scrollEnabled}\n          bounces={bounces}\n          initialNumToRender={MEASURE_PER_BATCH}\n          onViewableItemsChanged={handleViewableItemsChanged}\n          alwaysBounceHorizontal={false}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          showsVerticalScrollIndicator={false}\n          automaticallyAdjustContentInsets={false}\n          overScrollMode=\"never\"\n          contentContainerStyle={contentContainerStyleMemoized}\n          scrollEventThrottle={16}\n          renderItem={renderItem}\n          onScroll={handleScroll}\n          ref={flatListRef}\n          testID={testID}\n        />\n      </View>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0,\n    },\n    zIndex: 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}