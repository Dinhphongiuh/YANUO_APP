{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport findNodeHandleRN from \"react-native-web/dist/exports/findNodeHandle\";\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport { ghQueueMicrotask } from '../ghQueueMicrotask';\nconst commonProps = ['id', 'enabled', 'shouldCancelWhenOutside', 'hitSlop', 'cancelsTouchesInView', 'userSelect', 'activeCursor', 'mouseButton', 'enableContextMenu', 'touchAction'];\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers', 'blocksHandlers'];\nexport const baseGestureHandlerProps = [...commonProps, ...componentInteractionProps, 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange'];\nexport const baseGestureHandlerWithMonitorProps = [...commonProps, 'needsPointerData', 'manualActivation'];\nexport let MouseButton;\n(function (MouseButton) {\n  MouseButton[MouseButton[\"LEFT\"] = 1] = \"LEFT\";\n  MouseButton[MouseButton[\"RIGHT\"] = 2] = \"RIGHT\";\n  MouseButton[MouseButton[\"MIDDLE\"] = 4] = \"MIDDLE\";\n  MouseButton[MouseButton[\"BUTTON_4\"] = 8] = \"BUTTON_4\";\n  MouseButton[MouseButton[\"BUTTON_5\"] = 16] = \"BUTTON_5\";\n  MouseButton[MouseButton[\"ALL\"] = 31] = \"ALL\";\n})(MouseButton || (MouseButton = {}));\nfunction isConfigParam(param, name) {\n  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n}\nexport function filterConfig(props, validProps, defaults = {}) {\n  const filteredConfig = _objectSpread({}, defaults);\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = {\n          top: value,\n          left: value,\n          bottom: value,\n          right: value\n        };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\nfunction transformIntoHandlerTags(handlerIDs) {\n  handlerIDs = toArray(handlerIDs);\n  if (Platform.OS === 'web') {\n    return handlerIDs.map(({\n      current\n    }) => current).filter(handle => handle);\n  }\n  return handlerIDs.map(handlerID => {\n    var _handlerID$current;\n    return handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;\n  }).filter(handlerTag => handlerTag > 0);\n}\nexport function findNodeHandle(node) {\n  if (Platform.OS === 'web') {\n    return node;\n  }\n  return findNodeHandleRN(node);\n}\nlet flushOperationsScheduled = false;\nexport function scheduleFlushOperations() {\n  if (!flushOperationsScheduled) {\n    flushOperationsScheduled = true;\n    ghQueueMicrotask(() => {\n      RNGestureHandlerModule.flushOperations();\n      flushOperationsScheduled = false;\n    });\n  }\n}","map":{"version":3,"names":["handlerIDToTag","toArray","RNGestureHandlerModule","ghQueueMicrotask","commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","MouseButton","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","filteredConfig","_objectSpread","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Platform","OS","map","current","filter","handle","handlerID","_handlerID$current","handlerTag","findNodeHandle","node","findNodeHandleRN","flushOperationsScheduled","scheduleFlushOperations","flushOperations"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-gesture-handler\\lib\\module\\handlers\\gestureHandlerCommon.ts"],"sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\n\nimport { State } from '../State';\nimport { TouchEventType } from '../TouchEventType';\nimport { ValueOf } from '../typeUtils';\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport { ghQueueMicrotask } from '../ghQueueMicrotask';\nimport { PointerType } from '../PointerType';\n\nconst commonProps = [\n  'id',\n  'enabled',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'cancelsTouchesInView',\n  'userSelect',\n  'activeCursor',\n  'mouseButton',\n  'enableContextMenu',\n  'touchAction',\n] as const;\n\nconst componentInteractionProps = [\n  'waitFor',\n  'simultaneousHandlers',\n  'blocksHandlers',\n] as const;\n\nexport const baseGestureHandlerProps = [\n  ...commonProps,\n  ...componentInteractionProps,\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport const baseGestureHandlerWithMonitorProps = [\n  ...commonProps,\n  'needsPointerData',\n  'manualActivation',\n];\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  pointerType: PointerType;\n}\nexport interface HandlerStateChangeEventPayload extends GestureEventPayload {\n  oldState: ValueOf<typeof State>;\n}\n\nexport type HitSlop =\n  | number\n  | Partial<\n      Record<\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n        number\n      >\n    >\n  | Record<'width' | 'left', number>\n  | Record<'width' | 'right', number>\n  | Record<'height' | 'top', number>\n  | Record<'height' | 'bottom', number>;\n\nexport type UserSelect = 'none' | 'auto' | 'text';\nexport type ActiveCursor =\n  | 'auto'\n  | 'default'\n  | 'none'\n  | 'context-menu'\n  | 'help'\n  | 'pointer'\n  | 'progress'\n  | 'wait'\n  | 'cell'\n  | 'crosshair'\n  | 'text'\n  | 'vertical-text'\n  | 'alias'\n  | 'copy'\n  | 'move'\n  | 'no-drop'\n  | 'not-allowed'\n  | 'grab'\n  | 'grabbing'\n  | 'e-resize'\n  | 'n-resize'\n  | 'ne-resize'\n  | 'nw-resize'\n  | 's-resize'\n  | 'se-resize'\n  | 'sw-resize'\n  | 'w-resize'\n  | 'ew-resize'\n  | 'ns-resize'\n  | 'nesw-resize'\n  | 'nwse-resize'\n  | 'col-resize'\n  | 'row-resize'\n  | 'all-scroll'\n  | 'zoom-in'\n  | 'zoom-out';\n\nexport enum MouseButton {\n  LEFT = 1,\n  RIGHT = 2,\n  MIDDLE = 4,\n  BUTTON_4 = 8,\n  BUTTON_5 = 16,\n  ALL = 31,\n}\n\nexport type TouchAction =\n  | 'auto'\n  | 'none'\n  | 'pan-x'\n  | 'pan-left'\n  | 'pan-right'\n  | 'pan-y'\n  | 'pan-up'\n  | 'pan-down'\n  | 'pinch-zoom'\n  | 'manipulation'\n  | 'inherit'\n  | 'initial'\n  | 'revert'\n  | 'revert-layer'\n  | 'unset';\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\nexport type TouchData = {\n  id: number;\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type GestureTouchEvent = {\n  handlerTag: number;\n  numberOfTouches: number;\n  state: ValueOf<typeof State>;\n  eventType: TouchEventType;\n  allTouches: TouchData[];\n  changedTouches: TouchData[];\n};\n\nexport type GestureUpdateEvent<GestureEventPayloadT = Record<string, unknown>> =\n  GestureEventPayload & GestureEventPayloadT;\n\nexport type GestureStateChangeEvent<\n  GestureStateChangeEventPayloadT = Record<string, unknown>\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\n\nexport type CommonGestureConfig = {\n  enabled?: boolean;\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?: HitSlop;\n  userSelect?: UserSelect;\n  activeCursor?: ActiveCursor;\n  mouseButton?: MouseButton;\n  enableContextMenu?: boolean;\n  touchAction?: TouchAction;\n};\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = CommonGestureConfig & {\n  id?: string;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  blocksHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  testID?: string;\n  cancelsTouchesInView?: boolean;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n  // implicit `children` prop has been removed in @types/react^18.0.0\n  children?: React.ReactNode;\n};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nexport function filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const filteredConfig = { ...defaults };\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = { top: value, left: value, bottom: value, right: value };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\nexport function findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') {\n    return node;\n  }\n  return findNodeHandleRN(node);\n}\n\nlet flushOperationsScheduled = false;\n\nexport function scheduleFlushOperations() {\n  if (!flushOperationsScheduled) {\n    flushOperationsScheduled = true;\n    ghQueueMicrotask(() => {\n      RNGestureHandlerModule.flushOperations();\n\n      flushOperationsScheduled = false;\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}