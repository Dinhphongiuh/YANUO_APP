{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { EventTypes, TouchEventType } from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\nimport { PointerType } from '../../PointerType';\nexport default class TouchEventManager extends EventManager {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"touchStartCallback\", event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.DOWN, i, TouchEventType.DOWN);\n        if (!isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y\n        }) || event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        this.markAsInBounds(adaptedEvent.pointerId);\n        if (++this.activePointersCounter > 1) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n          this.onPointerAdd(adaptedEvent);\n        } else {\n          this.onPointerDown(adaptedEvent);\n        }\n      }\n    });\n    _defineProperty(this, \"touchMoveCallback\", event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.MOVE, i, TouchEventType.MOVE);\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        const inBounds = isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y\n        });\n        const pointerIndex = this.pointersInBounds.indexOf(adaptedEvent.pointerId);\n        if (inBounds) {\n          if (pointerIndex < 0) {\n            adaptedEvent.eventType = EventTypes.ENTER;\n            this.onPointerEnter(adaptedEvent);\n            this.markAsInBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerMove(adaptedEvent);\n          }\n        } else {\n          if (pointerIndex >= 0) {\n            adaptedEvent.eventType = EventTypes.LEAVE;\n            this.onPointerLeave(adaptedEvent);\n            this.markAsOutOfBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerOutOfBounds(adaptedEvent);\n          }\n        }\n      }\n    });\n    _defineProperty(this, \"touchEndCallback\", event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        if (this.activePointersCounter === 0) {\n          break;\n        }\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        const adaptedEvent = this.mapEvent(event, EventTypes.UP, i, TouchEventType.UP);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        if (--this.activePointersCounter > 0) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n          this.onPointerRemove(adaptedEvent);\n        } else {\n          this.onPointerUp(adaptedEvent);\n        }\n      }\n    });\n    _defineProperty(this, \"touchCancelCallback\", event => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent = this.mapEvent(event, EventTypes.CANCEL, i, TouchEventType.CANCELLED);\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n        this.onPointerCancel(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        this.activePointersCounter = 0;\n      }\n    });\n  }\n  registerListeners() {\n    this.view.addEventListener('touchstart', this.touchStartCallback);\n    this.view.addEventListener('touchmove', this.touchMoveCallback);\n    this.view.addEventListener('touchend', this.touchEndCallback);\n    this.view.addEventListener('touchcancel', this.touchCancelCallback);\n  }\n  unregisterListeners() {\n    this.view.removeEventListener('touchstart', this.touchStartCallback);\n    this.view.removeEventListener('touchmove', this.touchMoveCallback);\n    this.view.removeEventListener('touchend', this.touchEndCallback);\n    this.view.removeEventListener('touchcancel', this.touchCancelCallback);\n  }\n  mapEvent(event, eventType, index, touchEventType) {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType\n    };\n  }\n}","map":{"version":3,"names":["EventTypes","TouchEventType","EventManager","isPointerInBounds","PointerType","TouchEventManager","constructor","args","_defineProperty","event","i","changedTouches","length","adaptedEvent","mapEvent","DOWN","view","x","y","touchType","markAsInBounds","pointerId","activePointersCounter","eventType","ADDITIONAL_POINTER_DOWN","onPointerAdd","onPointerDown","MOVE","inBounds","pointerIndex","pointersInBounds","indexOf","ENTER","onPointerEnter","onPointerMove","LEAVE","onPointerLeave","markAsOutOfBounds","onPointerOutOfBounds","UP","ADDITIONAL_POINTER_UP","onPointerRemove","onPointerUp","CANCEL","CANCELLED","onPointerCancel","registerListeners","addEventListener","touchStartCallback","touchMoveCallback","touchEndCallback","touchCancelCallback","unregisterListeners","removeEventListener","index","touchEventType","rect","getBoundingClientRect","clientX","clientY","offsetX","left","offsetY","top","identifier","pointerType","TOUCH","time","timeStamp","allTouches","touches"],"sources":["C:\\Users\\DinhPhongIUH\\Desktop\\nhap\\Yanuo_mobile_Redux\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\TouchEventManager.ts"],"sourcesContent":["import { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\nimport { PointerType } from '../../PointerType';\n\nexport default class TouchEventManager extends EventManager<HTMLElement> {\n  private touchStartCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.DOWN,\n        i,\n        TouchEventType.DOWN\n      );\n\n      // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents\n      // If we leave stylus to send touch events, handlers will receive every action twice\n      if (\n        !isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y,\n        }) ||\n        //@ts-ignore touchType field does exist\n        event.changedTouches[i].touchType === 'stylus'\n      ) {\n        continue;\n      }\n\n      this.markAsInBounds(adaptedEvent.pointerId);\n\n      if (++this.activePointersCounter > 1) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n        this.onPointerAdd(adaptedEvent);\n      } else {\n        this.onPointerDown(adaptedEvent);\n      }\n    }\n  };\n\n  private touchMoveCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.MOVE,\n        i,\n        TouchEventType.MOVE\n      );\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      const inBounds: boolean = isPointerInBounds(this.view, {\n        x: adaptedEvent.x,\n        y: adaptedEvent.y,\n      });\n\n      const pointerIndex: number = this.pointersInBounds.indexOf(\n        adaptedEvent.pointerId\n      );\n\n      if (inBounds) {\n        if (pointerIndex < 0) {\n          adaptedEvent.eventType = EventTypes.ENTER;\n          this.onPointerEnter(adaptedEvent);\n          this.markAsInBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerMove(adaptedEvent);\n        }\n      } else {\n        if (pointerIndex >= 0) {\n          adaptedEvent.eventType = EventTypes.LEAVE;\n          this.onPointerLeave(adaptedEvent);\n          this.markAsOutOfBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerOutOfBounds(adaptedEvent);\n        }\n      }\n    }\n  };\n\n  private touchEndCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      // When we call reset on gesture handlers, it also resets their event managers\n      // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n      // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n      // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n      if (this.activePointersCounter === 0) {\n        break;\n      }\n\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.UP,\n        i,\n        TouchEventType.UP\n      );\n\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n      if (--this.activePointersCounter > 0) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n        this.onPointerRemove(adaptedEvent);\n      } else {\n        this.onPointerUp(adaptedEvent);\n      }\n    }\n  };\n\n  private touchCancelCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.CANCEL,\n        i,\n        TouchEventType.CANCELLED\n      );\n\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      this.onPointerCancel(adaptedEvent);\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n      this.activePointersCounter = 0;\n    }\n  };\n\n  public registerListeners(): void {\n    this.view.addEventListener('touchstart', this.touchStartCallback);\n    this.view.addEventListener('touchmove', this.touchMoveCallback);\n    this.view.addEventListener('touchend', this.touchEndCallback);\n    this.view.addEventListener('touchcancel', this.touchCancelCallback);\n  }\n\n  public unregisterListeners(): void {\n    this.view.removeEventListener('touchstart', this.touchStartCallback);\n    this.view.removeEventListener('touchmove', this.touchMoveCallback);\n    this.view.removeEventListener('touchend', this.touchEndCallback);\n    this.view.removeEventListener('touchcancel', this.touchCancelCallback);\n  }\n\n  protected mapEvent(\n    event: TouchEvent,\n    eventType: EventTypes,\n    index: number,\n    touchEventType: TouchEventType\n  ): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}